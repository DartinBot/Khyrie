"""
Advanced Workout Tools with Comprehensive Database Integration
Sophisticated workout analytics, progression tracking, and AI-powered insights
"""

import sqlite3
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from comprehensive_fitness_models import ComprehensiveFitnessDatabase
import uuid

class AdvancedWorkoutTools:
    """Advanced workout management with comprehensive analytics and AI insights"""
    
    def __init__(self, db_path: str = "comprehensive_fitness.db"):
        self.db = ComprehensiveFitnessDatabase(db_path)
        self.db_path = db_path
    
    # ===============================
    # WORKOUT PROGRAM CREATION
    # ===============================
    
    def create_workout_program(self, creator_id: str, name: str, description: str,
                              duration_weeks: int, frequency_per_week: int,
                              difficulty_level: str, goals: List[str],
                              exercises: List[Dict], progression_scheme: Dict) -> Dict:
        """Create a comprehensive workout program with progression"""
        program_id = f"prog_{uuid.uuid4().hex[:8]}"
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO workout_programs 
                (program_id, name, description, creator_id, duration_weeks, 
                 frequency_per_week, difficulty_level, goals, exercises, 
                 progression_scheme, created_at, is_public)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                program_id, name, description, creator_id, duration_weeks,
                frequency_per_week, difficulty_level, json.dumps(goals),
                json.dumps(exercises), json.dumps(progression_scheme),
                datetime.utcnow().isoformat(), False
            ))
            
            conn.commit()
        
        return {
            "program_id": program_id,
            "name": name,
            "duration_weeks": duration_weeks,
            "frequency_per_week": frequency_per_week,
            "total_workouts": duration_weeks * frequency_per_week,
            "created_at": datetime.utcnow().isoformat(),
            "status": "created"
        }
    
    def generate_adaptive_program(self, user_id: str, goals: List[str], 
                                 available_days: int, session_length: int) -> Dict:
        """Generate AI-powered adaptive workout program"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Get user data
            cursor.execute('''
                SELECT fitness_level, injuries, preferences 
                FROM users_enhanced WHERE user_id = ?
            ''', (user_id,))
            
            user_data = cursor.fetchone()
            if not user_data:
                raise ValueError("User not found")
            
            fitness_level, injuries, preferences = user_data
            injuries = json.loads(injuries) if injuries else []
            preferences = json.loads(preferences) if preferences else {}
            
            # Get recent performance data
            cursor.execute('''
                SELECT AVG(total_volume_kg), AVG(rpe_score)
                FROM workout_sessions_enhanced 
                WHERE user_id = ? AND date(created_at) > date('now', '-30 days')
            ''', (user_id,))
            
            performance_data = cursor.fetchone()
            avg_volume = performance_data[0] or 0
            avg_rpe = performance_data[1] or 5
            
        # AI-powered program generation logic
        program_template = self._generate_program_template(
            goals, available_days, session_length, fitness_level, 
            injuries, avg_volume, avg_rpe
        )
        
        return self.create_workout_program(
            creator_id=user_id,
            name=f"AI Generated Program - {', '.join(goals)}",
            description="Personalized program generated by AI based on your goals and fitness data",
            duration_weeks=program_template["duration_weeks"],
            frequency_per_week=available_days,
            difficulty_level=fitness_level,
            goals=goals,
            exercises=program_template["exercises"],
            progression_scheme=program_template["progression"]
        )
    
    def _generate_program_template(self, goals: List[str], days: int, 
                                  session_length: int, fitness_level: str,
                                  injuries: List[str], avg_volume: float,
                                  avg_rpe: float) -> Dict:
        """Generate program template based on parameters"""
        
        # Base exercise selection based on goals
        exercise_pool = {
            "strength": ["ex_001", "ex_002", "deadlift", "overhead_press"],
            "muscle_gain": ["ex_001", "ex_002", "deadlift", "rows", "dips"],
            "endurance": ["running", "cycling", "rowing", "circuit_training"],
            "weight_loss": ["circuit_training", "hiit", "compound_movements"]
        }
        
        # Select exercises based on primary goal
        primary_goal = goals[0] if goals else "strength"
        selected_exercises = exercise_pool.get(primary_goal, exercise_pool["strength"])
        
        # Adjust for fitness level
        intensity_modifier = {
            "beginner": {"sets": 2, "reps": "12-15", "intensity": 0.6},
            "intermediate": {"sets": 3, "reps": "8-12", "intensity": 0.75},
            "advanced": {"sets": 4, "reps": "5-8", "intensity": 0.85}
        }
        
        base_params = intensity_modifier.get(fitness_level, intensity_modifier["intermediate"])
        
        exercises = []
        for i, exercise_id in enumerate(selected_exercises[:days]):
            exercises.append({
                "exercise_id": exercise_id,
                "sets": base_params["sets"],
                "reps": base_params["reps"],
                "intensity_percentage": base_params["intensity"],
                "rest_seconds": 120 if "strength" in goals else 90,
                "day": (i % days) + 1
            })
        
        return {
            "duration_weeks": 8,
            "exercises": exercises,
            "progression": {
                "type": "linear",
                "weekly_increase": 2.5,
                "deload_frequency": 4
            }
        }
    
    # ===============================
    # ADVANCED ANALYTICS
    # ===============================
    
    def calculate_strength_standards(self, user_id: str, exercise_id: str) -> Dict:
        """Calculate strength standards and percentiles"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Get user data
            cursor.execute('''
                SELECT current_weight_kg, gender FROM users_enhanced WHERE user_id = ?
            ''', (user_id,))
            
            user_data = cursor.fetchone()
            if not user_data:
                raise ValueError("User not found")
            
            bodyweight, gender = user_data
            
            # Get latest 1RM
            cursor.execute('''
                SELECT one_rep_max FROM strength_progression 
                WHERE user_id = ? AND exercise_id = ? 
                ORDER BY date DESC LIMIT 1
            ''', (user_id, exercise_id))
            
            latest_1rm = cursor.fetchone()
            current_1rm = latest_1rm[0] if latest_1rm else 0
            
        # Strength standards (Wilks coefficient approximation)
        # These are simplified - real implementation would use comprehensive tables
        strength_standards = {
            "squat": {
                "male": {"beginner": 1.0, "novice": 1.25, "intermediate": 1.5, "advanced": 1.75, "elite": 2.0},
                "female": {"beginner": 0.75, "novice": 1.0, "intermediate": 1.25, "advanced": 1.5, "elite": 1.75}
            },
            "bench": {
                "male": {"beginner": 0.75, "novice": 1.0, "intermediate": 1.25, "advanced": 1.5, "elite": 1.75},
                "female": {"beginner": 0.5, "novice": 0.75, "intermediate": 1.0, "advanced": 1.25, "elite": 1.5}
            },
            "deadlift": {
                "male": {"beginner": 1.25, "novice": 1.5, "intermediate": 1.75, "advanced": 2.0, "elite": 2.25},
                "female": {"beginner": 1.0, "novice": 1.25, "intermediate": 1.5, "advanced": 1.75, "elite": 2.0}
            }
        }
        
        # Map exercise_id to standard categories
        exercise_mapping = {
            "ex_001": "squat",
            "ex_002": "bench",
            "deadlift": "deadlift"
        }
        
        exercise_category = exercise_mapping.get(exercise_id, "squat")
        user_standards = strength_standards[exercise_category][gender]
        
        # Calculate ratios
        ratio = current_1rm / bodyweight if bodyweight > 0 else 0
        
        # Determine level
        level = "untrained"
        for std_level, std_ratio in user_standards.items():
            if ratio >= std_ratio:
                level = std_level
        
        return {
            "current_1rm": current_1rm,
            "bodyweight": bodyweight,
            "ratio": round(ratio, 2),
            "level": level,
            "standards": user_standards,
            "percentile": self._calculate_percentile(ratio, user_standards),
            "next_goal": self._get_next_goal(ratio, user_standards)
        }
    
    def _calculate_percentile(self, ratio: float, standards: Dict) -> int:
        """Calculate approximate percentile based on standards"""
        levels = ["beginner", "novice", "intermediate", "advanced", "elite"]
        for i, level in enumerate(levels):
            if ratio < standards[level]:
                return (i / len(levels)) * 100
        return 95  # Elite level
    
    def _get_next_goal(self, current_ratio: float, standards: Dict) -> Dict:
        """Get next strength goal"""
        levels = ["beginner", "novice", "intermediate", "advanced", "elite"]
        for level in levels:
            if current_ratio < standards[level]:
                return {
                    "level": level,
                    "target_ratio": standards[level],
                    "percentage_to_goal": (current_ratio / standards[level]) * 100
                }
        return {"level": "elite", "target_ratio": standards["elite"], "percentage_to_goal": 100}
    
    def analyze_workout_trends(self, user_id: str, days: int = 90) -> Dict:
        """Comprehensive workout trend analysis"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Volume trend
            cursor.execute('''
                SELECT 
                    date(created_at) as workout_date,
                    AVG(total_volume_kg) as avg_volume,
                    COUNT(*) as workout_count
                FROM workout_sessions_enhanced 
                WHERE user_id = ? AND date(created_at) > date('now', '-{} days')
                GROUP BY date(created_at)
                ORDER BY workout_date
            '''.format(days), (user_id,))
            
            volume_data = cursor.fetchall()
            
            # RPE trend
            cursor.execute('''
                SELECT 
                    date(created_at) as workout_date,
                    AVG(rpe_score) as avg_rpe
                FROM workout_sessions_enhanced 
                WHERE user_id = ? AND rpe_score IS NOT NULL 
                AND date(created_at) > date('now', '-{} days')
                GROUP BY date(created_at)
                ORDER BY workout_date
            '''.format(days), (user_id,))
            
            rpe_data = cursor.fetchall()
            
            # Calculate trends
            volume_trend = self._calculate_trend([row[1] for row in volume_data])
            rpe_trend = self._calculate_trend([row[1] for row in rpe_data if row[1]])
            
        return {
            "volume_trend": {
                "direction": volume_trend["direction"],
                "slope": volume_trend["slope"],
                "data_points": len(volume_data)
            },
            "rpe_trend": {
                "direction": rpe_trend["direction"],
                "slope": rpe_trend["slope"],
                "data_points": len(rpe_data)
            },
            "consistency": {
                "workout_frequency": len(volume_data) / (days / 7),
                "weekly_consistency": self._calculate_consistency(volume_data)
            },
            "recommendations": self._generate_trend_recommendations(volume_trend, rpe_trend)
        }
    
    def _calculate_trend(self, values: List[float]) -> Dict:
        """Calculate trend direction and slope"""
        if len(values) < 2:
            return {"direction": "insufficient_data", "slope": 0}
        
        # Simple linear regression
        n = len(values)
        x_vals = list(range(n))
        
        sum_x = sum(x_vals)
        sum_y = sum(values)
        sum_xy = sum(x * y for x, y in zip(x_vals, values))
        sum_x2 = sum(x * x for x in x_vals)
        
        slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
        
        direction = "increasing" if slope > 0.1 else "decreasing" if slope < -0.1 else "stable"
        
        return {"direction": direction, "slope": slope}
    
    def _calculate_consistency(self, volume_data: List) -> float:
        """Calculate workout consistency score"""
        if not volume_data:
            return 0.0
        
        # Simple consistency based on workout frequency
        total_days = (len(volume_data) * 7) / len(volume_data) if volume_data else 0
        consistency = min(len(volume_data) / (total_days / 7), 1.0) if total_days > 0 else 0
        
        return round(consistency * 100, 1)
    
    def _generate_trend_recommendations(self, volume_trend: Dict, rpe_trend: Dict) -> List[str]:
        """Generate recommendations based on trends"""
        recommendations = []
        
        if volume_trend["direction"] == "decreasing":
            recommendations.append("Consider increasing workout volume gradually")
        elif volume_trend["direction"] == "increasing" and rpe_trend["direction"] == "increasing":
            recommendations.append("Volume is increasing but RPE is also rising - consider a deload week")
        
        if rpe_trend["direction"] == "increasing":
            recommendations.append("Perceived exertion is trending upward - focus on recovery")
        
        if not recommendations:
            recommendations.append("Your training trends look consistent - keep up the good work!")
        
        return recommendations
    
    # ===============================
    # AI-POWERED INSIGHTS
    # ===============================
    
    def generate_ai_workout_recommendation(self, user_id: str) -> Dict:
        """Generate AI-powered workout recommendations"""
        analytics = self.db.get_user_analytics(user_id, days=30)
        trends = self.analyze_workout_trends(user_id, days=30)
        
        # AI recommendation logic
        recommendations = []
        priority = "medium"
        
        # Analyze volume trends
        if trends["volume_trend"]["direction"] == "decreasing":
            recommendations.append({
                "type": "volume",
                "message": "Your training volume has decreased recently. Consider adding an extra set to your main lifts.",
                "action": "increase_volume"
            })
            priority = "high"
        
        # Analyze consistency
        if trends["consistency"]["workout_frequency"] < 2.5:
            recommendations.append({
                "type": "consistency",
                "message": "Aim to workout at least 3 times per week for optimal results.",
                "action": "improve_frequency"
            })
            priority = "high"
        
        # Analyze RPE trends
        if trends["rpe_trend"]["direction"] == "increasing":
            recommendations.append({
                "type": "recovery",
                "message": "Your perceived exertion is trending up. Consider a deload week or extra rest day.",
                "action": "focus_recovery"
            })
        
        # Default positive recommendation
        if not recommendations:
            recommendations.append({
                "type": "progression",
                "message": "Your training is progressing well! Consider adding a new exercise variation.",
                "action": "add_variation"
            })
        
        return {
            "recommendations": recommendations,
            "priority": priority,
            "confidence": 0.85,
            "generated_at": datetime.utcnow().isoformat(),
            "based_on": {
                "workout_count": analytics["workout_stats"]["total_workouts"],
                "volume_trend": trends["volume_trend"]["direction"],
                "consistency": trends["consistency"]["workout_frequency"]
            }
        }
    
    def predict_injury_risk(self, user_id: str) -> Dict:
        """AI-powered injury risk prediction"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Get recent workout data
            cursor.execute('''
                SELECT rpe_score, total_volume_kg, 
                       (julianday(end_time) - julianday(start_time)) * 24 * 60 as duration
                FROM workout_sessions_enhanced 
                WHERE user_id = ? AND rpe_score IS NOT NULL
                AND date(created_at) > date('now', '-14 days')
                ORDER BY created_at DESC
            ''', (user_id,))
            
            recent_workouts = cursor.fetchall()
            
            # Get user injury history
            cursor.execute('''
                SELECT injuries FROM users_enhanced WHERE user_id = ?
            ''', (user_id,))
            
            injuries = cursor.fetchone()
            injury_history = json.loads(injuries[0]) if injuries and injuries[0] else []
        
        # Risk calculation logic
        risk_factors = []
        risk_score = 0
        
        if recent_workouts:
            avg_rpe = sum(row[0] for row in recent_workouts) / len(recent_workouts)
            volume_trend = self._calculate_trend([row[1] for row in recent_workouts])
            
            # High RPE risk
            if avg_rpe > 8.5:
                risk_factors.append("High average RPE (>8.5)")
                risk_score += 30
            
            # Rapid volume increase
            if volume_trend["direction"] == "increasing" and volume_trend["slope"] > 10:
                risk_factors.append("Rapid volume increase")
                risk_score += 25
            
            # Insufficient recovery
            if len(recent_workouts) > 10:  # More than 10 workouts in 14 days
                risk_factors.append("High workout frequency without adequate rest")
                risk_score += 20
        
        # Injury history factor
        if injury_history:
            risk_factors.append(f"Previous injuries: {', '.join(injury_history)}")
            risk_score += len(injury_history) * 10
        
        # Determine risk level
        if risk_score < 20:
            risk_level = "Low"
        elif risk_score < 40:
            risk_level = "Moderate"
        elif risk_score < 60:
            risk_level = "High"
        else:
            risk_level = "Very High"
        
        return {
            "risk_level": risk_level,
            "risk_score": min(risk_score, 100),
            "risk_factors": risk_factors,
            "recommendations": self._generate_injury_prevention_recommendations(risk_level, risk_factors),
            "generated_at": datetime.utcnow().isoformat()
        }
    
    def _generate_injury_prevention_recommendations(self, risk_level: str, risk_factors: List[str]) -> List[str]:
        """Generate injury prevention recommendations"""
        recommendations = []
        
        if risk_level in ["High", "Very High"]:
            recommendations.extend([
                "Consider taking 2-3 rest days before next workout",
                "Focus on mobility and flexibility exercises",
                "Reduce workout intensity by 20-30%",
                "Schedule a check-in with a fitness professional"
            ])
        elif risk_level == "Moderate":
            recommendations.extend([
                "Include extra warm-up time (10+ minutes)",
                "Monitor RPE closely and aim to stay under 8",
                "Add one extra rest day this week"
            ])
        else:
            recommendations.extend([
                "Maintain current workout routine",
                "Continue monitoring recovery markers",
                "Consider progressive overload opportunities"
            ])
        
        return recommendations

if __name__ == "__main__":
    # Test the advanced workout tools
    tools = AdvancedWorkoutTools()
    
    # Test program creation
    program = tools.generate_adaptive_program(
        user_id="user_001",
        goals=["strength", "muscle_gain"],
        available_days=3,
        session_length=60
    )
    
    print("ðŸ“‹ Generated Program:", json.dumps(program, indent=2))
    
    # Test analytics
    analytics = tools.analyze_workout_trends("user_001")
    print("ðŸ“Š Workout Trends:", json.dumps(analytics, indent=2))